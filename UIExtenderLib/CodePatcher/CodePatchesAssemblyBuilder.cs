using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using HarmonyLib;
using TaleWorlds.Engine;
using Path = System.IO.Path;

namespace UIExtenderLib.PatchAssembly
{
    /// <summary>
    /// AssemblyBuilder-like class which represents mod-specific assembly
    /// containing extended view models (generated by ViewModelComponent) and
    /// Harmony patches (generated by CodePatcherComponent into UIExtender_ModAssembly_MODULENAME_StaticLibrary class).
    /// </summary>
    internal class CodePatchesAssemblyBuilder
    {
        internal static string TypeNamePrefix = "UIExtender_";
        
        private readonly string _moduleName;
        private readonly string _dllName;
        private readonly AssemblyBuilder _assemblyBuilder;
        private readonly ModuleBuilder _moduleBuilder;
        
        private readonly TypeBuilder _staticLibType;
        private readonly string _staticLibName;

        internal CodePatchesAssemblyBuilder(string moduleName)
        {
            _moduleName = moduleName;
           
            _dllName = $"UIExtender_PatchAssembly_{_moduleName}.dll";
            var assembly = new AssemblyName($"UIExtender_PatchAssembly_{_moduleName}");
            _assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(assembly, AssemblyBuilderAccess.Run | AssemblyBuilderAccess.Save);
            _moduleBuilder = _assemblyBuilder.DefineDynamicModule(
                $"UIExtender_PatchAssemblyModule_{_moduleName}", 
                _dllName
            );

            _staticLibName = $"UIExtender_ModAssembly_{_moduleName}_StaticLibrary";
            _staticLibType = _moduleBuilder.DefineType(_staticLibName);
        }

        /// <summary>
        /// Add transpiler to library class. `staticArgs` will be added in front of usual IEnumerable<CodeInstruction> argument.
        /// </summary>
        /// <param name="name"></param>
        /// <param name="proxyTo">transpiler this method will be proxied to</param>
        /// <param name="staticArgs">array of static arguments that will prepend Harmony's CodeInstruction array. Only strings, integers, Types and array of Types are supported as of now</param>
        internal void AddTranspiler(string name, MethodInfo proxyTo, params object[] staticArgs)
        {
            var method = _staticLibType.DefineMethod(
                name,
                MethodAttributes.Static | MethodAttributes.Public,
                typeof(IEnumerable<CodeInstruction>),
                new Type[] {typeof(IEnumerable<CodeInstruction>)}
            );

            var gen = method.GetILGenerator();
            ILLoadArguments(gen, staticArgs);
            gen.Emit(OpCodes.Ldarg_0);
            gen.EmitCall(OpCodes.Call, proxyTo, null);
            gen.Emit(OpCodes.Ret);
        }

        /// <summary>
        /// Add postfix to library class. `staticArgs` will be added in front of __instance argument.
        /// </summary>
        /// <param name="name"></param>
        /// <param name="proxyTo">postfix this method will be proxied to. Required to accept __instance argument</param>
        /// <param name="staticArgs">array of static arguments that will prepend Harmony's CodeInstruction array. Only strings and int's are supported as of now</param>
        internal void AddPostfix(string name, MethodInfo proxyTo, params object[] staticArgs)
        {
            var method = _staticLibType.DefineMethod(
                name,
                MethodAttributes.Static | MethodAttributes.Public,
                null,
                new Type[] {typeof(object)}
            );

            // state name of the parameter in order for Harmony to recognize it
            method.DefineParameter(1, ParameterAttributes.None, "__instance");

            var gen = method.GetILGenerator();
            ILLoadArguments(gen, staticArgs);
            gen.Emit(OpCodes.Ldarg_0);
            gen.EmitCall(OpCodes.Call, proxyTo, null);
            gen.Emit(OpCodes.Ret);
        }

        /// <summary>
        /// Save generated dll and load static library class from it.
        /// Finalizes dll meaning `AddX` methods can no longer be used.
        /// </summary>
        /// <returns></returns>
        internal Type SaveAndLoadLibraryType()
        {
            _staticLibType.CreateType();
            _assemblyBuilder.Save(_dllName);
            
            var targetPath = Path.Combine(Utils.GeneratedDllDirectory(), _dllName);
            if (File.Exists(targetPath))
            {
                File.Delete(targetPath);
            }
            
            File.Move(_dllName, targetPath);
            var assembly = Assembly.LoadFile(Path.GetFullPath(targetPath));
            return assembly.GetType(_staticLibName);
        }

        private static void ILLoadArguments(ILGenerator gen, object[] args)
        {
            foreach (var arg in args)
            {
                switch (arg)
                {
                    case string str:
                        gen.Emit(OpCodes.Ldstr, str);
                        break;
                    case int num:
                        gen.Emit(OpCodes.Ldc_I4, num);
                        break;
                    case Type t:
                        gen.Emit(OpCodes.Ldtoken, t);
                        gen.EmitCall(OpCodes.Call, typeof(Type).GetMethod(nameof(Type.GetTypeFromHandle)), null);
                        break;
                    case IEnumerable<Type> ta:
                        gen.Emit(OpCodes.Ldc_I4, ta.Count());
                        gen.Emit(OpCodes.Newarr, typeof(Type));
                        gen.Emit(OpCodes.Dup);
                        for (int i = 0; i < ta.Count(); i++)
                        {
                            var value = ta.ElementAt(i);
                            gen.Emit(OpCodes.Ldc_I4, i);
                            gen.Emit(OpCodes.Ldtoken, value);
                            gen.EmitCall(OpCodes.Call, typeof(Type).GetMethod(nameof(Type.GetTypeFromHandle)), null);
                            gen.Emit(OpCodes.Stelem_Ref);
                        }
                        break;
                    default:
                        Debug.Fail($"Type of {arg} is not supported by this method!");
                        break;
                }
            }
        }
    }
}
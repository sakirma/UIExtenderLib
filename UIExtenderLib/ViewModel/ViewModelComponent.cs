using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using TaleWorlds.Library;
using UIExtenderLib.Interface;
using UIExtenderLib.CodePatcher.StaticLibrary;
using UIExtenderLib.PatchAssembly;
using Debug = System.Diagnostics.Debug;

namespace UIExtenderLib.ViewModel
{
    /// <summary>
    /// Component that deals with extended VM generation and runtime support
    /// </summary>
    internal class ViewModelComponent
    {
        private readonly string _moduleName;
        private readonly string _typeNamePrefix = "UIExtender_";
        private readonly AssemblyBuilder _assemblyBuilder;
        private readonly string _dllName;
        private readonly ModuleBuilder _moduleBuilder;
        
        /// <summary>
        /// List of registered mixin types
        /// </summary>
        private readonly Dictionary<Type, List<Type>> _mixins = new Dictionary<Type, List<Type>>();
        
        /// <summary>
        /// Cache dictionary of extended VM types
        /// </summary>
        private readonly Dictionary<Type, Type> _extendedTypeCache = new Dictionary<Type, Type>();
        
        /// <summary>
        /// Cache of mixin instances. Key is generated by `mixinCacheKey`. Instances are removed when original view model is deallocated
        /// </summary>
        private readonly Dictionary<string, List<IViewModelMixin>> _mixinInstanceCache = new Dictionary<string, List<IViewModelMixin>>();

        internal ViewModelComponent(string moduleName)
        {
            _moduleName = moduleName;
            
            _dllName = $"UIExtender_VMAssembly_{_moduleName}.dll";
            var assembly = new AssemblyName($"UIExtender_VMAssembly_{_moduleName}");
            
            _assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(assembly, AssemblyBuilderAccess.RunAndSave);
            _moduleBuilder = _assemblyBuilder.DefineDynamicModule(
                $"UIExtender_VMAssemblyModule_{_moduleName}", 
                _dllName
            );
        }

         /// <summary>
         /// Register mixin type.
         /// </summary>
         /// <param name="mixinType">mixin type, should be a subclass of ViewModelMixin<T> where T specify view model to extend</param>
        internal void RegisterViewModelMixin(Type mixinType)
        {
            Type viewModelType = null;
            var node = mixinType;
            while (node != null)
            {
                if (typeof(IViewModelMixin).IsAssignableFrom(node))
                {
                    viewModelType = node.GetGenericArguments().FirstOrDefault();
                    if (viewModelType != null)
                    {
                        break;
                    }
                }

                node = node.BaseType;
            }

            Debug.Assert(viewModelType != null, $"Failed to find base type for mixin {mixinType}, should be specialized as T of ViewModelMixin<T>!");
            _mixins.Get(viewModelType, () => new List<Type>()).Add(mixinType);
        }

        /// <summary>
        /// Check if any mixins are extending type t
        /// </summary>
        /// <param name="t"></param>
        /// <returns></returns>
        internal bool ExtendsViewModelType(Type t)
        {
            return _mixins.ContainsKey(t);
        }

        /// <summary>
        /// Find base type for type that was possibly extended by other instances.
        /// Recursively looks at parents skipping ones starting with standard `_typeNamePrefix`.
        /// Returns same type if it's not one of the extended types.
        /// </summary>
        /// <param name="t"></param>
        /// <returns></returns>
        internal Type BaseTypeForPossiblyExtendedType(Type t)
        {
            while (t != null)
            {
                if (t.Name.StartsWith(_typeNamePrefix))
                {
                    t = t.BaseType;
                }
                else
                {
                    break;
                }
            }

            return t;
        }
        
        /// <summary>
        /// Fetch mixin instance from cache for specified mixin type and extended view model instance.
        /// Used in extended VM methods to proxy calls to mixin that yielded that method.
        /// Requires extended VM constructor to run first (which will create instances).
        /// </summary>
        /// <param name="mixinType">type of a mixin</param>
        /// <param name="instance">instance of VM</param>
        /// <returns></returns>
        internal IViewModelMixin MixinInstanceForVMInstance(Type mixinType, object instance)
        {
            var mixinInstance = mixinCacheList(instance).FirstOrDefault(m => m.GetType() == mixinType);
            Debug.Assert(mixinInstance != null, $"Mixin instance (of type {mixinType}) not (yet) created for {instance}!");
            return mixinInstance;
        }
        
        /// <summary>
        /// Get extended view model type for specified base type (view model).
        /// Generates that type if it is not found in cache, setting it's parent type to the `parentType`
        /// (which can be another extended VM type).
        /// Should only be called if `ExtendsViewModelType()` returned true for type.
        /// Used to swap constructors in transcribed instantiation callsites for view models.
        /// </summary>
        /// <param name="baseType">original type of VM (found in game)</param>
        /// <param name="parentType">parent type for newly generated type (can either equal to base to to extended VM from another instance)</param>
        /// <returns></returns>
        internal Type ExtendedViewModelTypeForType(Type baseType, Type parentType)
        {
            return _extendedTypeCache.Get(baseType, () =>
            {
                var type = GenerateExtendedVMTypeFor(baseType, parentType);
                return type;
            });
        }

        /// <summary>
        /// Initialize mixin instances for specified view model instance, called in extended VM constructor.
        /// </summary>
        /// <param name="baseType">base type of VM (as found in game)</param>
        /// <param name="instance">instance of extended VM</param>
        internal void InitializeMixinsForVMInstance(Type baseType, object instance)
        {
            var list = mixinCacheList(instance);
            
            foreach (var mixinType in _mixins[baseType])
            {
                list.Add((IViewModelMixin)Activator.CreateInstance(mixinType, new [] { instance }));
            }
        }

        /// <summary>
        /// Calls `OnRefresh` on mixins associated with view model instance,
        /// specifics are determined by VM model patch (usually during `OnRefresh`-like method in VM).
        /// </summary>
        /// <param name="instance"></param>
        internal void RefreshMixinForVMInstance(object instance)
        {
            foreach (var mixin in mixinCacheList(instance))
            {
                mixin.OnRefresh();
            }
        }

        /// <summary>
        /// Calls `OnFinalize` on mixins associated with view model instance,
        /// called during extended view models `OnFinalize` (Gauntlet method).
        /// </summary>
        /// <param name="instance"></param>
        internal void FinalizeMixinForVMInstance(object instance)
        {
            foreach (var mixin in mixinCacheList(instance))
            {
                mixin.OnFinalize();
            }
        }

        /// <summary>
        /// Destruct mixins associated with view model instance,
        /// called when respective VM destructor is called.
        /// </summary>
        /// <param name="instance"></param>
        internal void DestructMixinsForVMInstance(object instance)
        {
            _mixinInstanceCache.Remove(mixinCacheKey(instance));
        }

        /// <summary>
        /// Generate extended VM type in _assemblyBuilder for base type (found in game), with parent set as `parentType`
        /// (can be either base type or other instance extended type).
        /// </summary>
        /// <param name="baseType"></param>
        /// <param name="parentType"></param>
        /// <returns></returns>
        private Type GenerateExtendedVMTypeFor(Type baseType, Type parentType)
        {
            Debug.Assert(_mixins.ContainsKey(baseType), $"Invalid extended vm generation call - type {baseType} is not registered!");

            var getTypeFromHandle = typeof(Type).GetMethod(nameof(Type.GetTypeFromHandle));
            var getMixinInstance = typeof(UIExtenderRuntimeLib).GetMethod(nameof(UIExtenderRuntimeLib.MixinInstanceForVMInstance));
            Debug.Assert(getTypeFromHandle != null && getMixinInstance != null);

            var builder =  _moduleBuilder.DefineType(
                _typeNamePrefix + _moduleName + baseType.Name,
                TypeAttributes.Class | TypeAttributes.Public, 
                parentType
            );
            
            {
                // constructor
                var defaultConstructor = parentType.GetConstructors().First();
                var constructorSignature = defaultConstructor.GetParameters().Select(p => p.ParameterType).ToArray();

                var constructor = builder.DefineConstructor(
                    MethodAttributes.Public,
                    CallingConventions.Standard,
                    constructorSignature
                );

                {
                    var gen = constructor.GetILGenerator();

                    // call base constructor
                    for (int i = 0; i < constructorSignature.Length + 1; i++)
                    {
                        gen.Emit(OpCodes.Ldarg, i);
                    }

                    gen.Emit(OpCodes.Call, defaultConstructor);

                    // instaniate mixins of this type
                    var instantiateMixins = typeof(UIExtenderRuntimeLib).GetMethod(nameof(UIExtenderRuntimeLib.InitializeMixinsForVMInstance));
                    gen.Emit(OpCodes.Ldstr, _moduleName);
                    gen.Emit(OpCodes.Ldtoken, baseType);
                    gen.Emit(OpCodes.Ldarg_0);
                    gen.Emit(OpCodes.Call, instantiateMixins);

                    gen.Emit(OpCodes.Ret);
                }
            }

            {
                // destructor
                var finalizer = builder.DefineMethod("Finalize", MethodAttributes.Family | MethodAttributes.ReuseSlot | MethodAttributes.HideBySig | MethodAttributes.Virtual);
                var existingFinalizer = parentType.GetMethod("Finalize", BindingFlags.Instance | BindingFlags.NonPublic);

                var gen = finalizer.GetILGenerator();
                
                if (existingFinalizer != null)
                {
                    gen.Emit(OpCodes.Ldarg_0);
                    gen.EmitCall(OpCodes.Call, existingFinalizer, null);
                }
                
                var destructMixins = typeof(UIExtenderRuntimeLib).GetMethod(nameof(UIExtenderRuntimeLib.DestructMixinsForVMInstance));
                gen.Emit(OpCodes.Ldstr, _moduleName);
                gen.Emit(OpCodes.Ldarg_0);
                gen.EmitCall(OpCodes.Call, destructMixins, null);
                gen.Emit(OpCodes.Ret);
            }

            {
                // OnFinalize
                var method = builder.DefineMethod("OnFinalize", MethodAttributes.Public | MethodAttributes.ReuseSlot | MethodAttributes.HideBySig | MethodAttributes.Virtual);
                var existingMethod = parentType.GetMethod("OnFinalize", BindingFlags.Instance | BindingFlags.Public | BindingFlags.FlattenHierarchy);

                var gen = method.GetILGenerator();
                if (existingMethod != null)
                {
                    gen.Emit(OpCodes.Ldarg_0);
                    gen.EmitCall(OpCodes.Call, existingMethod, null);
                }
                
                var finalizeMixins = typeof(UIExtenderRuntimeLib).GetMethod(nameof(UIExtenderRuntimeLib.FinalizeMixinsForVMInstance));
                gen.Emit(OpCodes.Ldstr, _moduleName);
                gen.Emit(OpCodes.Ldarg_0);
                gen.EmitCall(OpCodes.Call, finalizeMixins, null);
                gen.Emit(OpCodes.Ret);
            }

            foreach (var mixin in _mixins[baseType])
            {
                // properties
                foreach (var property in mixin.GetProperties().Where(p => p.CustomAttributes.Any(a => a.AttributeType == typeof(DataSourceProperty))))
                {
                    var newProperty = builder.DefineProperty(property.Name, PropertyAttributes.None, property.PropertyType, new Type[] {});
                    var attributeConstructor = typeof(DataSourceProperty).GetConstructor(new Type[] { });
                    var customBuilder = new CustomAttributeBuilder(attributeConstructor, new object[] {});
                    newProperty.SetCustomAttribute(customBuilder);
                    
                    // getter
                    MethodAttributes getSetAttr = MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig;
                    var newMethod = builder.DefineMethod("get_" + property.Name, getSetAttr, property.PropertyType, Type.EmptyTypes);
                    var gen = newMethod.GetILGenerator();
                    
                    // body
                    var method = property.GetGetMethod();

                    gen.Emit(OpCodes.Ldstr, _moduleName);
                    gen.Emit(OpCodes.Ldtoken, mixin);
                    gen.Emit(OpCodes.Call, getTypeFromHandle);
                    gen.Emit(OpCodes.Ldarg_0);
                    gen.Emit(OpCodes.Call, getMixinInstance);
                    gen.Emit(OpCodes.Call, method);
                    gen.Emit(OpCodes.Ret);
                    
                    newProperty.SetGetMethod(newMethod);
                }

                // methods
                foreach (var method in mixin.GetMethods().Where(m => m.CustomAttributes.Any(a => a.AttributeType == typeof(DataSourceMethod))))
                {
                    var newMethod = builder.DefineMethod(method.Name, MethodAttributes.Public, null, new Type[] { });
                    var gen = newMethod.GetILGenerator();

                    // body
                    gen.Emit(OpCodes.Ldstr, _moduleName);
                    gen.Emit(OpCodes.Ldtoken, mixin);
                    gen.Emit(OpCodes.Call, getTypeFromHandle);
                    gen.Emit(OpCodes.Ldarg_0);
                    gen.Emit(OpCodes.Call, getMixinInstance);
                    gen.Emit(OpCodes.Call, method);
                    gen.Emit(OpCodes.Ret);
                }
            }
            
            return builder.CreateType();
        }

        /// <summary>
        /// Save dll files (used only for debugging).
        /// Finalizes dll meaning new types can no longer be added.
        /// </summary>
        internal void SaveDebugImages()
        {
            _assemblyBuilder.Save(_dllName);
            
            var targetPath = Path.Combine(Utils.GeneratedDllDirectory(), _dllName);
            if (File.Exists(targetPath))
            {
                File.Delete(targetPath);
            }
            
            File.Move(_dllName, targetPath);
        }

        /// <summary>
        /// Construct string key for _mixinInstanceCache
        /// </summary>
        /// <param name="instance"></param>
        /// <returns></returns>
        private string mixinCacheKey(object instance)
        {
            return instance.GetType() + "_" + instance.GetHashCode();
        }

        /// <summary>
        /// Get list of mixin instances from _mixinInstanceCache associated with VM instance
        /// </summary>
        /// <param name="instance"></param>
        /// <returns></returns>
        private List<IViewModelMixin> mixinCacheList(object instance)
        {
            var key = mixinCacheKey(instance);
            return _mixinInstanceCache.Get(key, () => new List<IViewModelMixin>());
        }
    }
}